// Generated by dts-bundle-generator v9.5.1

declare namespace wsc {
	interface DataObject {
		[key: string]: any;
	}
	type WSEvent = "open" | "message" | "close" | "error" | "timeout";
	/** Minimal socket-like interface. */
	interface Socket {
		readyState: number;
		send(...any: any[]): void;
		close(): void;
		addEventListener: WebSocket["addEventListener"];
		removeEventListener: WebSocket["removeEventListener"];
	}
	type AsyncErrCode = Promise<number | null | {}>;
	type EventHandler = (e: any) => void;
	type DataPipe = (message: any) => any;
	type DataType = "json" | "string";
	interface Config {
		data_type: DataType;
		log(event: string, time?: number | null, message?: any): void;
		log(event: string, message?: any): void;
		timer: boolean;
		url: string;
		timeout: number;
		reconnect: number;
		reconnection_attempts: number;
		max_idle_time: number;
		lazy: boolean;
		socket: Socket | null;
		adapter: (host: string, protocols?: string[]) => Socket;
		encode: (key: string, message: any, config: Config) => any;
		decode: (rawMessage: any) => {
			[id_or_data_key: string]: string;
		};
		protocols: string[];
		pipes: DataPipe[];
		server: {
			id_key: string;
			data_key: string;
		};
		ping: {
			interval: number;
			content: any;
		};
	}
	type UserConfig = Partial<Config>;
	type SendOptions = Partial<{
		top: any;
		data_type: DataType;
		_is_ping: boolean;
	}>;
	interface Message {
		msg: any;
		ff(x: any): any;
		data_type: DataType;
		sent_time: number | null;
		timeout: NodeJS.Timeout;
	}
}
declare class WebSocketClient {
	private ws;
	private intentionally_closed;
	private reconnect_timeout;
	private queue;
	private onReadyQueue;
	private onCloseQueue;
	private handlers;
	private config;
	private ping_timer;
	private idle_timer;
	private get opened();
	private init_flush;
	private call;
	private log;
	private resetPing;
	private resetIdle;
	private initSocket;
	private opening;
	private connect;
	get socket(): wsc.Socket | null;
	ready(): Promise<void>;
	on(event_name: wsc.WSEvent, handler: (data: any) => any, predicate?: (data: any) => boolean, raw?: boolean): wsc.EventHandler;
	off(event_name: wsc.WSEvent, handler: (data: any) => any, raw?: boolean): void;
	close(): wsc.AsyncErrCode;
	open(): Promise<number | null> | undefined;
	/**  .send(your_data) wraps request to server with {id: `hash`, data: `actually your data`},
	  returns a Promise that will be rejected after a timeout or
	  resolved if server returns the same signature: {id: `same_hash`, data: `response data`}.
	*/
	send<RequestDataType = any, ResponseDataType = any>(message_data: RequestDataType, opts?: wsc.SendOptions): Promise<ResponseDataType>;
	constructor(user_config?: wsc.UserConfig);
}

export {
	WebSocketClient as default,
};

export {};
